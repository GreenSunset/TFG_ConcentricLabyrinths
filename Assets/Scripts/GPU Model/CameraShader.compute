// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Source;
RWTexture2D<float4> Destination;

struct Capsule {
    float3 pos1;
    float3 pos2;
    float radius;
};

struct Shape {
    float3 position;
    float size;
    int type;
    float4 color;
};

struct Light {
    float3 direction;
    float intensity;
};

struct Ray {
    float3 origin;
    float3 direction;
};


RWStructuredBuffer<Capsule> Capsules;
int CapsuleCount = 0;


RWStructuredBuffer<Light> Lights;
int LightCount = 0;

RWStructuredBuffer<Shape> Shapes;
int ShapeCount = 0;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float Ratio = 0.5;


float CubeDistance(float3 pov, float3 position, float size)
{
    float3 o = abs(pov - position) - size;
    float ud = length(max(o, 0.0));
    float n = max(max(min(o.x,0), min(o.y, 0)), min(o.z, 0));
    return ud+n;
}

float SphereDistance(float3 pov, float3 position, float radius)
{
    return distance(pov, position) - radius;
}

float CapsuleDistance(float3 pov, Capsule cap)
{
    float3 mainLine = normalize((cap.pos2 - cap.pos1));
    if (dot((pov - cap.pos1), mainLine) < 0) {
        return SphereDistance(pov, cap.pos1, cap.radius);
    } else if (dot((pov - cap.pos2), -mainLine) < 0) {
        return SphereDistance(pov, cap.pos2, cap.radius);
    } else {
        float3 perp = cross(mainLine, pov - cap.pos1);
        float dist = length(perp);
        return dist - cap.radius;
    }
    return 1;
}

float Distance (float3 pov, Shape shape) {
    if (shape.type == 0) {
        return SphereDistance(pov, shape.position, shape.size);
    } else {
        return CubeDistance(pov, shape.position, shape.size);
    }
}

float3 CubeNormal(float3 hit, float3 position)
{
    float3 n = hit - position;
    float3 absN = abs(n);
    float maxAxis = max(max(absN.x, absN.y), absN.z);
    if (maxAxis == absN.x) {
        return float3(sign(n.x), 0, 0);
    } else if (maxAxis == absN.y) {
        return float3(0, sign(n.y), 0);
    } else {
        return float3(0, 0, sign(n.z));
    }
}

float3 SphereNormal(float3 hit, float3 position)
{
    return normalize(hit - position);
}

float3 CapsuleNormal(float3 hit, Capsule cap) {
    float3 mainLine = normalize((cap.pos2 - cap.pos1));
    if (dot((hit - cap.pos1), mainLine) < 0) {
        return SphereNormal(hit, cap.pos1);
    } else if (dot((hit - cap.pos2), -mainLine) < 0) {
        return SphereNormal(hit, cap.pos2);
    } else {
        float coef = dot(hit - cap.pos1, mainLine) / dot(mainLine, mainLine);
        float3 projHit = coef * mainLine + cap.pos1;
        float3 perp = hit - projHit;
        return normalize(perp);
    }

}

float3 Normal(float3 hit, Shape shape) {
    if (shape.type == 0) {
        return SphereNormal(hit, shape.position);
    } else {
        return CubeNormal(hit, shape.position);
    }
}

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0,0,0,1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv,0,1)).xyz;
    direction = mul(_CameraToWorld, float4(direction,0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin,direction);
}

float4 RayHit(Ray ray, Capsule cap, float4 color) {
    float totalLight = 0;
    float3 normal = CapsuleNormal(ray.origin, cap);
    for (int i = 0; i < LightCount; i++) {
        Light light = Lights[i];
        totalLight += dot(normal, -normalize(light.direction));
    }
    return color * totalLight;
}

float4 RayHit(Ray ray, Shape shape) {
    float totalLight = 0;
    float3 normal = Normal(ray.origin, shape);
    for (int i = 0; i < LightCount; i++) {
        Light light = Lights[i];
        totalLight += dot(normal, -normalize(light.direction));
    }
    return shape.color * totalLight;
}

[numthreads(32, 32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    uint width,height;
    Destination.GetDimensions(width, height);

    Destination[id.xy] = Source[id.xy];
    float2 uv = id.xy / float2(width,height) * 2 - 1;

    Ray ray = CameraRay(uv);
    float4 color = float4(ray.direction, 0.0);
    float maxDist = 100;
    float totalDist = 0;
    while (totalDist < maxDist) {
        if (CapsuleCount == 0) {
            break;
        }
        float minDistance = 50000;
        int index = -1;
        for (int j = 0; j < CapsuleCount; j++) {
            Capsule cap = Capsules[j];
            float dist = CapsuleDistance(ray.origin, cap);
            if (dist < minDistance) {
                minDistance = dist;
                index = j;
            }
        }
        if (minDistance < 0.001) {
            color = RayHit(ray, Capsules[index], float4(1,1,1,1));// RayHit(ray, Shapes[index]);
            break;
        }
        ray.origin = ray.origin + ray.direction * minDistance;
        totalDist = totalDist + minDistance;
    }
    Destination[id.xy] = Ratio * Source[id.xy] + (1 - Ratio) * color;
}
