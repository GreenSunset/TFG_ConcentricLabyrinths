// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RayMarching
#pragma kernel Render

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Source;
RWTexture2D<float4> RayMarch;
RWTexture2D<float4> Destination;

StructuredBuffer<float3> Points;
int PointCount = 0;
float3 MazePos;
float MazeRadius;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float Ratio = 0.5;

struct Ray {
    float3 origin;
    float3 direction;
};

struct Shape {
    float3 position;
    float size;
    int type;
    float4 color;
};

Shape CreateShape(float3 position, float size, int type, float4 color) {
    Shape shape;
    shape.position = position;
    shape.size = size;
    shape.type = type;
    shape.color = color;
    return shape;
}

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0,0,0,1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv,0,1)).xyz;
    direction = mul(_CameraToWorld, float4(direction,0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin,direction);
}

float CubeDistance(float3 pov, float3 position, float size) {
    float3 o = abs(pov - position) - size;
    float ud = length(max(o, 0.0));
    float n = max(max(min(o.x,0), min(o.y, 0)), min(o.z, 0));
    return ud+n;
}

float SphereDistance(float3 pov, float3 position, float radius) {
    return distance(pov, position) - radius;
}

float3 MazeDistance(float3 pov, float cutRadius, int closest, int second = -1) {
    float3 p1 = Points[closest] + MazePos;
    float mainDis = CubeDistance(pov, MazePos, MazeRadius);
    float cutDis = SphereDistance(pov, p1, cutRadius);
    if (second != -1) {
        float3 p2 = Points[second] + MazePos;
        float3 cutLine = normalize(p2 - p1);
        if (dot((pov - p2), -cutLine) < 0) {
            cutDis = SphereDistance(pov, p2, cutRadius);
        } else if (dot((pov - p1), cutLine) > 0) {
            float3 perp = cross(cutLine, pov - p1);
            float dist = length(perp);
            cutDis = dist - cutRadius;
        }
    }
    return float3(-mainDis, cutDis, -mainDis < cutDis ? 0 : 1);
}

float3 CubeNormal(float3 hit, float3 position) {
    float3 n = hit - position;
    float3 absN = abs(n);
    float maxAxis = max(max(absN.x, absN.y), absN.z);
    if (maxAxis == absN.x) {
        return float3(sign(n.x), 0, 0);
    } else if (maxAxis == absN.y) {
        return float3(0, sign(n.y), 0);
    } else {
        return float3(0, 0, sign(n.z));
    }
}

float3 SphereNormal(float3 hit, float3 position) {
    return CubeNormal(hit,position);//normalize(hit - position);
}

float3 ShapeNormal(float3 hit, Shape shape) {
    if (shape.type == 0) {
        return SphereNormal(hit, shape.position);
    } else {
        return CubeNormal(hit, shape.position);
    }
}

float3 MazeNormal(float3 hit, float cas, int closest, int second = -1) {
    float3 p1 = Points[closest] + MazePos;
    if (cas == 0) {
        return CubeNormal(hit, MazePos);
    }
    float3 cutNormal = SphereNormal(hit, p1);
    if (second != -1) {
        float3 p2 = Points[second] + MazePos;
        float3 cutLine = normalize(p2 - p1);
        if (dot((hit - p2), -cutLine) < 0) {
            cutNormal = SphereNormal(hit, p2);
        } else if (dot((hit - p1), cutLine) > 0) {
            float coef = dot(hit - p1, cutLine) / dot(cutLine, cutLine);
            float3 projHit = coef * cutLine + p1;
            float3 perp = hit - projHit;
            cutNormal = normalize(perp);
        }
    }
    return -cutNormal;
}

int2 GetClosestPoint(float3 pov) {
    int closest = -1;
    int second = -1;
    float closestDist = 1000000;
    float secondDist = 1000000;
    for (int i = 0; i < PointCount; i++) {
        float dist = SphereDistance(pov, Points[i] + MazePos, 0.3);
        if (dist < closestDist) {
            secondDist = closestDist;
            second = closest;
            closestDist = dist;
            closest = i;
        } else if (dist < secondDist) {
            secondDist = dist;
            second = i;
        }
    }
    return int2(closest, second);
}

float4 MazeHit(Ray ray) {
    float4 color = float4(ray.direction,1);
    float maxDist =  2 * MazeRadius;
    float totalDist = 0;
    float dist;
    Shape shape;
    int2 closest = GetClosestPoint(ray.origin).x;
    if (closest.x == -1) {
        return color;
    }
    while (totalDist < maxDist) {
        float3 distInfo = MazeDistance(ray.origin, 0.3, closest.x, closest.y);
        float cas = distInfo.z;
        dist = abs(distInfo[cas]);
        if (dist < 0.0001) {
            color = float4(1,1,1,1);
            return color * dot(MazeNormal(ray.origin, cas, closest.x, closest.y), -normalize(float3(2,3,1)));
        }
        if (dist > 10) {
            break;
        }
        ray.origin += ray.direction * dist;
        totalDist += dist;
        if (distInfo.y > 5) {
            closest = GetClosestPoint(ray.origin);
        }
    }
    return color;
}

[numthreads(32, 32,1)]
void RayMarching (uint3 id : SV_DispatchThreadID)
{
    uint width,height;
    RayMarch.GetDimensions(width, height);

    float2 uv = id.xy / float2(width,height) * 2 - 1;

    Ray ray = CameraRay(uv);
    float4 color = float4(ray.direction, 0.0);
    float maxDist = 1000;
    float totalDist = 0;
    
    while (totalDist < maxDist) {
       float dist = CubeDistance(ray.origin, MazePos, MazeRadius);
       if (dist < 0.5) {
           color = MazeHit(ray);
           break;
       }
       ray.origin += ray.direction * dist;
       totalDist += dist;
    }
    RayMarch[id.xy] = color;
}

[numthreads(32, 32,1)]
void Render (uint3 id : SV_DispatchThreadID)
{
    uint width,height;
    Destination.GetDimensions(width, height);
    Destination[id.xy] = Ratio * Source[id.xy];
    // Destination[id.xy] = Ratio * Source[id.xy] + (1 - Ratio) / 4 * (RayMarch[id.xy + uint2(1,0)] + RayMarch[id.xy + uint2(-1,0)] + RayMarch[id.xy + uint2(0,1)] + RayMarch[id.xy + uint2(0,-1)]);
}
