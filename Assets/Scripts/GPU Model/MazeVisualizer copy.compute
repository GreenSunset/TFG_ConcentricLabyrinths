// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> Source;
RWTexture2D<float4> Destination;

struct Capsule {
    float3 pos1;
    float3 pos2;
    float radius;
};

struct Shape {
    float3 position;
    float size;
    int type;
    float4 color;
};

struct Light {
    float3 direction;
    float intensity;
};

struct Ray {
    float3 origin;
    float3 direction;
};


RWStructuredBuffer<float3> Points;
RWStructuredBuffer<int> Adjacency;
int PointCount = 0;
int MazeSize = 0;
float3 MazePos = 0;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float Ratio = 0.5;


bool isAdjacent(int i, int j) {
    return Adjacency[i * PointCount + j] == 1;
}

float CubeDistance(float3 pov, float3 position, float size)
{
    float3 o = abs(pov - position) - size;
    float ud = length(max(o, 0.0));
    float n = max(max(min(o.x,0), min(o.y, 0)), min(o.z, 0));
    return ud+n;
}

float SphereDistance(float3 pov, float3 position, float radius)
{
    return distance(pov, position) - radius;
}

float CapsuleDistance(float3 pov, Capsule cap)
{
    float3 mainLine = normalize((cap.pos2 - cap.pos1));
    if (dot((pov - cap.pos1), mainLine) < 0) {
        return SphereDistance(pov, cap.pos1, cap.radius);
    } else if (dot((pov - cap.pos2), -mainLine) < 0) {
        return SphereDistance(pov, cap.pos2, cap.radius);
    } else {
        float3 perp = cross(mainLine, pov - cap.pos1);
        float dist = length(perp);
        return dist - cap.radius;
    }
    return 1;
}

float Distance (float3 pov, Shape shape) {
    if (shape.type == 0) {
        return SphereDistance(pov, shape.position, shape.size);
    } else {
        return CubeDistance(pov, shape.position, shape.size);
    }
}

float3 CubeNormal(float3 hit, float3 position)
{
    float3 n = hit - position;
    float3 absN = abs(n);
    float maxAxis = max(max(absN.x, absN.y), absN.z);
    if (maxAxis == absN.x) {
        return float3(sign(n.x), 0, 0);
    } else if (maxAxis == absN.y) {
        return float3(0, sign(n.y), 0);
    } else {
        return float3(0, 0, sign(n.z));
    }
}

float3 SphereNormal(float3 hit, float3 position)
{
    return normalize(hit - position);
}

float3 CapsuleNormal(float3 hit, Capsule cap) {
    float3 mainLine = normalize((cap.pos2 - cap.pos1));
    if (dot((hit - cap.pos1), mainLine) < 0) {
        return SphereNormal(hit, cap.pos1);
    } else if (dot((hit - cap.pos2), -mainLine) < 0) {
        return SphereNormal(hit, cap.pos2);
    } else {
        float coef = dot(hit - cap.pos1, mainLine) / dot(mainLine, mainLine);
        float3 projHit = coef * mainLine + cap.pos1;
        float3 perp = hit - projHit;
        return normalize(perp);
    }

}

float3 Normal(float3 hit, Shape shape) {
    if (shape.type == 0) {
        return SphereNormal(hit, shape.position);
    } else {
        return CubeNormal(hit, shape.position);
    }
}

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0,0,0,1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv,0,1)).xyz;
    direction = mul(_CameraToWorld, float4(direction,0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin,direction);
}

float4 RayHit(Ray ray, Shape shape) {
    float3 normal = Normal(ray.origin, shape);
    float totalLight = dot(normal, -normalize(float3(0,1,0)));
    return shape.color;
}

float4 RayHit(Ray ray, Capsule cap, float4 color) {
    float3 normal = CapsuleNormal(ray.origin, cap);
    float totalLight = dot(normal, -normalize(float3(0,1,0)));
    return color * totalLight;
}

float4 MazeModel(Ray ray, Shape mainBody, Capsule cap) {
    float4 color = float4(1,0,0,1);
    float mainDist = Distance(ray.origin, mainBody);
    float capDist = CapsuleDistance(ray.origin, cap);
    float d = max(mainDist, capDist);
    if (capDist < mainDist) {
        color = float4(1,1,1,1);
    }
    float maxDist = 100;
    float dist = 0;
    while (dist < maxDist) {
        if (d < 0.001) {
            break;
        }
        dist += d;
        ray.origin += ray.direction * d;
        mainDist = Distance(ray.origin, mainBody);
        capDist = CapsuleDistance(ray.origin, cap);
        d = max(mainDist, capDist);
    }
    return color;
}

float4 MazeHit(Ray ray, Shape mainBody) {
    float closestDist = 5000000;
    float secondClosestDist = 5000000;
    int closestIndex = -1;
    int secondClosestIndex = -1;
    for (int i = 0; i < PointCount; i++) {
        float dist = length(ray.origin - (Points[i] + MazePos));
        if (dist < closestDist) {
            secondClosestDist = closestDist;
            secondClosestIndex = closestIndex;
            closestDist = dist;
            closestIndex = i;
        } else if (dist < secondClosestDist) {
            secondClosestDist = dist;
            secondClosestIndex = i;
        }
    }
    if (closestIndex == -1) {
        return float4(0,0,0,1);
    } else if (secondClosestIndex == -1) {
        return float4(1,0,0,1);
    }
    Capsule cap;
    cap.pos1 = Points[closestIndex] + MazePos;
    cap.pos2 = Points[secondClosestIndex] + MazePos;
    cap.radius = .3;
    float dist = CapsuleDistance(ray.origin, cap);
    return MazeModel(ray, mainBody, cap);
}


[numthreads(32, 32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    uint width,height;
    Destination.GetDimensions(width, height);

    Destination[id.xy] = Source[id.xy];
    float2 uv = id.xy / float2(width,height) * 2 - 1;

    Ray ray = CameraRay(uv);
    float4 color = float4(ray.direction, 0.0);
    float maxDist = 100;
    float totalDist = 0;
    Shape mainBody;
    mainBody.position = MazePos;
    mainBody.size = MazeSize;
    mainBody.type = 1;
    mainBody.color = float4(0,0,0,1);
    while (totalDist < maxDist) {
       float dist = Distance(ray.origin, mainBody);
       if (dist < 0.01) {
           color = MazeHit(ray, mainBody);
           break;
       }
       ray.origin += ray.direction * dist;
       totalDist += dist;
    }
    Destination[id.xy] = Ratio * Source[id.xy] + (1 - Ratio) * color;
}
